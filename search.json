[{"title":"hexo 第一讲  -- 从头开始搭建hexo","url":"/2021/04/07/blog/hexo/hexo%20%E7%AC%AC%E4%B8%80%E8%AE%B2/","content":"hexo 第一讲\n从头开始搭建hexo安装node\nnode.js 官网\n\n安装稳定版本\n设置 git-ssh本地生成公钥和密钥ssh-keygen -t rsa -C &quot;邮箱&quot;\n\n第一个回车处可以看到该 .ssh  的路径\n几个回车之后，生成公钥和密钥。可以避免频繁输入 git 账号和密码\ngithub设置github中设置 ssh\n第一步中文件夹中的 id_rsa.pub 公钥复制到框中，取一个名字即可。\nhexo本地安装启动\nhexo中文官网\n\nnpm install hexo-cli -g\n\n输入上述官网首页的命令，可以在指定文件夹中 init hexo\n往下拉网页，可以看到如下命令\nnpm install hexo-cli -ghexo init blogcd blognpm installhexo s -p 5555\n\n则可以初步初始化 blog ，以及启动起来，在 localhost:5555 上\nhexo发布到github需要配置 hexo 的配置文件title: maoxf小站subtitle: 小站副标题description: 小站小描述keywords: maoxfauthor: maoxflanguage: zh-CNtimezone: Asia&#x2F;Shanghaiurl: https:&#x2F;&#x2F;hapitoku.github.iodeploy:  type: git  repo: https:&#x2F;&#x2F;github.com&#x2F;hapitoku&#x2F;maoxf-blog-source.git  branch: main\n\n\n\n安装插件根据  hexo部署文档 中的描述， 安装 hexo-deployer-git  。命令如下\nnpm install hexo-deployer-git --save\n\n\n\n执行命令hexo ghexo d\n\n输入账号密码以后，可以上传到  github 上。\n到这一步，就可以访问 我的博客 啦。\n下一节预警下一节会将 hexo 选择主题 以及 自动部署。\n","categories":["blog"],"tags":["hexo"]},{"title":"hexo 第三讲 -- hexo 中图床的选择和搭建","url":"/2021/04/07/blog/hexo/hexo%20%E7%AC%AC%E4%B8%89%E8%AE%B2/","content":"hexo 中图床的选择和搭建\nblog 图床图的问题。可以使用直接放在项目中的图片。\n图片放在项目中\n\n缺点：问题在于构建慢，并且各种环境可能都会产生影响，加载慢。\n优点：图片不会消失。\n可以直接用各种图库。可以使用 typora 支持的 ipic ，upic ， picgo 等等各种图片服务器。\n缺点：可能会需要翻墙才能访问。或者服务器挂了图片直接消失。\n优点：加载快，方便。\n用picxpicx 用 github 来存储图片，避免图片的消失。\n并且有 cdn 加速，保证了速度。\n安装方便，或者说不用安装，是更大的优点。\npicx\npicx github\npicx 官网 \n\n创建一个用来存储图片的 GitHub 仓库 。创建一个有 repo 权限的 GitHub Token 。进入 PicX 官网 ，进行图床配置（绑定 GitHub Token、存储图片的仓库和目录）。\n填写 Token，自动获取该用户下的仓库。\n\n在仓库的下拉列表中，选择一个作为图床的仓库。\n\n选择一种目录方式（目录即仓库里存放图片的文件夹）。\n\n新建目录：需手动输入一个新目录。\n根目录：图片将直接存储在仓库根目录下。\n自动目录：自动生成日期格式 YYYYMMDD 的目录。例如：20200909。\n选择仓库目录：自动获取仓库下所有目录，选择一个即可。\n\n\n\n至此完成图床配置，现在就可以开始上传图片了，快去试试吧~\n上传图片\n可通过 拖拽图片 到上传区域进行上传。\n可通过 复制粘贴图片 到上传区域进行上传。粘贴图片时，需先点击一下激活上传区域，如下图，上传区域的虚线边框变成墨蓝色，表示已激活，此时粘贴图片才生效。支持通过键盘快捷键粘贴（ctrl + v / command + v）。\n可通过 选择文件夹图片 到上传区域进行上传。\n\n选择图片完成后，会显示出图片详细信息，你可以 自定义修改图片名称 和 给图片加上哈希码（确保图片名不会重复）。\n图片上传成功后，即可复制图片外链。有 markdown 模式\n也有 github 直接地址 和  cdn 加速地址\n下一节预警下一节会介绍  typora 的使用方法。真的是神器呀\n","categories":["blog"],"tags":["hexo"]},{"title":"hexo 第二讲 -- hexo 的 主题选择 以及 自动部署","url":"/2021/04/07/blog/hexo/hexo%20%E7%AC%AC%E4%BA%8C%E8%AE%B2/","content":"hexo 的 主题选择 以及 自动部署\nhexo主题hexo主题选择\nhexo 主题官网\n\n可以选择各种主题。\n本人选择的是 keep\n主题的安装cd blognpm install hexo-theme-keep\n\n即可安装主题。\n并且需要在 hexo 的 _config.yml 配置文件中，进行如下配置。\ntheme: keep\n\n之后，重启 hexo\nhexo ghexo s -p 5555 \n\n即可看到已经更新。\n主题配置\n keep 主题配置详情 \n\n有需要的配置，在这里寻找即可。\n需要注意的是，分辨 hexo 的配置文件和 主题keep 中的配置文件。\nhexo自动部署为何引入自动部署一切重复且枯燥的工作都应该交给程序去自动完成，尤其是静态博客编译和部署，我们只需要专注文字。\n可以直接在线编辑 md 文件，立即生效。假设你已发布一篇文章，过几天你在别的电脑上浏览发现有几个明显的错别字，这是完全不能容忍的。但此时你电脑上又没有 hexo + node.js + git 等完整的开发环境，重新配置开发环境明显不现实。如果使用 CI，你可以直接用浏览器访问 GitHub 上的项目仓库，直接编辑带错别字的 md 文章，改完，在线提交，稍等片刻，你的网站就自动更新了。\n\n如何使用 GitHub Actions 自动部署 Hexo 博客\n\n可以参考上文，也可以参考下文。\n再创建一个私有仓库在第一讲中，创建的  *.github.io 是 public 仓库，用于展示。 之后会只存放 public 文件夹下的数据。\n下面需要新建一个 私有仓库。\n\n本例：\n\n用私有仓库的 main 分支来存储项目源代码。\n\n用公共仓库的 master  分支 来存储静态页面。\n\n\n创建 github token创建一个有 repo 和 workflow 权限的 GitHub Token \n\n新生成的 Token 只会显示一次，如有遗失，重新生成即可。\n创建 repository secret将上面生成的 Token 添加到私有仓库的 Secrets 里，并将这个新增的 secret 命名为 HEXO_DEPLOY\n\n添加 Actions 配置文件\n在你的 Hexo 项目根目录下创建 .github 文件夹。\n在 .github 文件夹下创建 workflows 文件夹。\n在 workflows 文件夹下创建 hexo-deploy.yml 文件。\n\n\nhexo-deploy.yml 文件的内容如下：\nname: deploying Hexo project to GitHub pageson:  push:    branches:      - main # main 分支有 push 行为时就触发这个 actionjobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@master      - name: Build and Deploy        uses: theme-keep/hexo-deploy-github-pages-action@master # 使用专门部署 Hexo 到 GitHub pages 的 action        env:          PERSONAL_TOKEN: $&#123;&#123; secrets.HEXO_DEPLOY &#125;&#125; # secret 名          PUBLISH_REPOSITORY: hapitoku/hapitoku.github.io # 公共仓库，格式：GitHub 用户名/仓库名          BRANCH: master # 分支，填 gh-pages 就行          PUBLISH_DIR: ./public # 部署 public 目录下的文件\n\n\nhexo-deploy-github-pages-action \n\n触发情况当 私有仓库 的main 分支有变动时，在几分钟内会触发 public 仓库的构建。非常nice\n下一节预警下一节中，会介绍 用github 来做图库。 用到 picx。\n","categories":["blog"],"tags":["hexo"]},{"title":"hexo 第四讲 -- 界面中加入音乐","url":"/2021/04/08/blog/hexo/hexo-%E7%AC%AC%E5%9B%9B%E8%AE%B2--%E7%95%8C%E9%9D%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E9%9F%B3%E4%B9%90/","content":"hexo中加入音乐第一种：用hexo 插件的方式\nhexo-tag-aplayer\n\n可以参考上面github界面配置。\n第二种：直接使用 外链形式。以下以网易云音乐中的 爱就一个字为例。  \n本人使用的是这种形式。\n进入音乐外链地址。\n得到 frame 地址\n上述 frame 直接使用则是如下。\n\n\n\n\n将其放入 theme 中进入  ../themes/keep/layout/_partial/heder.ejs  文件中\n&lt;!-- 音乐播放器 --&gt;&lt;% if (theme.bgm.enable === true) &#123; %&gt;    &lt;div&gt;        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=86   height=100 src=&quot;&lt;%= theme.bgm.url %&gt;&quot;&gt;&lt;/iframe&gt;    &lt;/div&gt;&lt;% &#125; %&gt;\n\n\n上述的  width , height   等字段可以根据自己需求调整。\n在 keep 的_config.yml 文件中配置注意！！  在 keep的配置文件中配置：\nbgm:  enable: true  url: &#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;33599439&amp;auto&#x3D;0&amp;height&#x3D;66\n\n\n\n查看效果查看在 web端的效果\n查看在 移动端 的效果\n下一节预警下一节是看 excel 的 从入门到精通 的教程。嘻嘻。\n","categories":["blog"],"tags":["hexo"]},{"title":"Typora 第一讲 -- Typora的安装使用","url":"/2021/04/08/blog/typora/Typora%20%E7%AC%AC%E4%B8%80%E8%AE%B2----Typora%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","content":"TyporaTypora的安装\nTypora官网\n\nTypora 基本配置Typora 和浏览器非常类似\n打开调试模式偏好设置 –》 通用 –》 开启调试模式\n之后，可以在md文件右键发现，有检查元素，和浏览器的基本类似。可以直接在弹出框中修改新样式。\n设置全局CSS上述配置中，只能在一个页面中生效。\n如果想要全局生效，可以在主题 中设置。\n偏好设置 –》外观 –》 打开主题文件夹\n可以看到，各个 css 文件，和配置中的主题是一一对应的。\n\n打开文件，对里面的样式可以进行自己喜欢的修改。\nTypora 主题自动编号对于各种标题，自己编号复杂且易出错。用上述所说的修改 css 样式，就可以实现自动编号。\n\n内容标题自动编号\n TOC 自动编号\n 侧边栏目录导航自动编号\n\n\n自动编号github地址\n\n效果如图所示\n\n","categories":["blog"],"tags":["Typora"]},{"title":"Typora 第二讲 -- md的基本使用","url":"/2021/04/08/blog/typora/Typora-%E7%AC%AC%E4%BA%8C%E8%AE%B2----md%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"MarkDown基础⚠️  表示，可能只能在 Typora 编辑器中使用。\n并且需要打开  偏好设置 –》 MarkDown –》 打开 上标，下标，高亮，图标  。 并且可以关闭 严格模式 。\n标题# 标题名字（井号的个数代表标题的级数）\n\n一级标题使用1个#二级标题使用2个#三级标题使用3个#四级标题使4用个#五级标题使用5个#六级标题使用6个######## 最多支持六级标题#\n文字删除线这就是 ~~删除线~~ (使用波浪号)\n\n这就是 删除线 (使用波浪号)\n斜体这是用来 *斜体* 的 _文本_\n\n这是用来 斜体 的 文本\n加粗这是用来 **加粗** 的 __文本__\n\n这是用来 加粗 的 文本\n斜体+加粗这是用来 ***斜体+加粗*** 的 ___文本___\n\n这是用来 斜体+加粗 的 文本\n下划线下划线是HTML语法\n下划线 下划线(快捷键command+u，所有的快捷键都是针对Mac系统，其他系统可自行查找)\n⚠️ 高亮（需勾选扩展语法）这是用来 ==斜体+加粗== 的文本\n\n这是用来 ==斜体+加粗== 的文本\n⚠️ 下标（需勾选扩展语法）水 H~2~O 双氧水 H~2~O~2~ \n\n水 H2O \n双氧水 H2O2\n⚠️ 上标（需勾选扩展语法）面积 m^2^ 体积 m^3^\n\n面积 m^2^体积 m^3^\n⚠️ 表情符号 Emoji 支持表情符号，你可以用系统默认的 Emoji 符号（ Windows 用户不一定支持，自己试下~）。 也可以用图片的表情，输入 : 将会出现智能提示。  \n一些表情例子:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary::+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:\n\n:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:\n(  Mac: control+command+space点选)\n表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：\nname | price--- | ---fried chicken | 19cola|5\n\n\n为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。\n\n\n\n\nname\nprice\n\n\n\nfried chicken\n19\n\n\ncola\n5\n\n\n为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界，在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式：\n|    name       | price || :------------ | :---: || fried chicken | 19    || cola          |  32   |\n\n\n\n\nname\nprice\n\n\n\nfried chicken\n19\n\n\ncola\n32\n\n\n使用快捷键command+opt+T更方便(段落→表格→插入表格，即可查看快捷键)\n引用&gt;“后悔创业”\n\n\n“后悔创业”\n\n&gt;也可以在引用中&gt;&gt;使用嵌套的引用\n\n\n也可以在引用中\n\n使用嵌套的引用\n\n\n列表无序列表–符号 空格* 可以使用 `*` 作为标记+ 也可以使用 `+`- 或者 `-`\n\n\n\n\n可以使用 * 作为标记\n\n\n也可以使用 +\n\n\n或者 -\n\n有序列表–数字 . 空格1. 有序列表以数字和 `.` 开始；3. 数字的序列并不会影响生成的列表序列；4. 但仍然推荐按照自然顺序（1.2.3...）编写。\n\n\n有序列表以数字和 . 开始；\n\n数字的序列并不会影响生成的列表序列；\n\n但仍然推荐按照自然顺序（1.2.3…）编写。\n可以使用：数字\\. 来取消显示为列表（用反斜杠进行转义）\n\n代码代码块​```语言名称\n\npublic static void main(String[] args) &#123;   &#125;\n\n行内代码也可以通过 ``,例如 `Markdown`\n\nMarkdown\n转换规则代码块中的文本（包括 Markdown 语法）都会显示为原始内容\n分隔线可以在一行中使用三个或更多的 *、- 或 _ 来添加分隔线（``）：\n***------___\n\n\n\n\n跳转外部跳转–超链接格式为 [link text](link)。\n[帮助文档](https://support.typora.io/Links/#faq)\n\n帮助文档\n内部跳转–本文件内跳（Typora支持）格式为 [link text](#要去的目的地--标题）。\n[我想跳转](#饼图（Pie）)\n\n\nOpen Links in Typora\nYou can use command+click (macOS), or ctrl+click (Linux/Windows) on links in Typora to jump to target headings, or open them in Typora, or open in related apps.\n\n我想跳转\n自动链接使用 &lt;&gt; 包括的 URL 或邮箱地址会被自动转换为超链接：\n&lt;https://www.baidu.com&gt;&lt;849715057@qq.com&gt;\n\nhttps://www.baidu.com\n849715057@qq.com\n图片![自己起的图片名字](图片地址或者图片本地存储的路径)\n\n网上的图片![0051](https://cdn.jsdelivr.net/gh/hapitoku/maoxf-bolg-images@main/netty/0051.md7yskvzn8.png)\n\n\n本地图片![friedChicken](friedChicken.jpg)在同一个文件夹里（用相对路径）或者直接拷贝\n\n\n\n8.1 中的url 换成一个相对路径。 可能加 ./ , 可能加 / ，可能都不加。需要根据自己的 theme 和 配置来看。\n⚠️ 利用Markdown画图（需勾选扩展语法）markdown画图也是轻量级的，功能并不全。\nMermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。\n（不同的编辑器渲染的可能不一样）\n\nTypora支持mermaid的官方链接\n\n流程图(graph)概述graph 方向描述    图表中的其他语句...\n\n关键字graph表示一个流程图的开始，同时需要指定该图的方向。\n其中“方向描述”为：\n\n\n\n用词\n含义\n\n\n\nTB\n从上到下\n\n\nBT\n从下到上\n\n\nRL\n从右到左\n\n\nLR\n从左到右\n\n\n\nT = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN\n\n最常用的布局方向是TB、LR。\ngraph TB;  A--&gt;B  B--&gt;C  C--&gt;A \n\ngraph TB;  A--&gt;B  B--&gt;C  C--&gt;A\n\n\n\n\n\ngraph LR;  A--&gt;B  B--&gt;C  C--&gt;A\n\n\n\ngraph LR;  A--&gt;B  B--&gt;C  C--&gt;A\n\n流程图常用符号及含义节点形状\n\n\n表述\n说明\n含义\n\n\n\nid[文字]\n矩形节点\n表示过程，也就是整个流程中的一个环节\n\n\nid(文字)\n圆角矩形节点\n表示开始和结束\n\n\nid((文字))\n圆形节点\n表示连接。为避免流程过长或有交叉，可将流程切开。成对\n\n\nid{文字}\n菱形节点\n表示判断、决策\n\n\nid&gt;文字]\n右向旗帜状节点\n\n\n\n单向箭头线段：表示流程进行方向\n\nid即为节点的唯一标识，A~F 是当前节点名字，类似于变量名，画图时便于引用\n括号内是节点中要显示的文字，默认节点的名字和显示的文字都为A\n\ngraph TB  A  B(圆角矩形节点)  C[矩形节点]  D((圆形节点))  E&#123;菱形节点&#125;  F&gt;右向旗帜状节点] \n\ngraph TB  A  B(圆角矩形节点)  C[矩形节点]  D((圆形节点))  E&#123;菱形节点&#125;  F&gt;右向旗帜状节点]\n\n\n\ngraph TB    begin(出门)--&gt; buy[买炸鸡]    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack    \n\ngraph TB    begin(出门)--&gt; buy[买炸鸡]    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack    \n\n\n\n\n\n连线graph TB  A1--&gt;B1  A2---B2  A3--text---B3  A4--text--&gt;B4  A5-.-B5  A6-.-&gt;B6  A7-.text.-B7  A8-.text.-&gt;B8  A9===B9  A10==&gt;B10  A11==text===B11  A12==text==&gt;B12\n\ngraph TB  A1--&gt;B1  A2---B2  A3--text---B3  A4--text--&gt;B4  A5-.-B5  A6-.-&gt;B6  A7-.text.-B7  A8-.text.-&gt;B8  A9&#x3D;&#x3D;&#x3D;B9  A10&#x3D;&#x3D;&gt;B10  A11&#x3D;&#x3D;text&#x3D;&#x3D;&#x3D;B11  A12&#x3D;&#x3D;text&#x3D;&#x3D;&gt;B12\n\ngraph TB A ---B\n\n\n\n子图表使用以下语法添加子图表\nsubgraph 子图表名称    子图表中的描述语句...end\n\ngraph TB\t  subgraph 买炸鸡前   \t\t\t begin(出门)--&gt; buy[出门买炸鸡]    end    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack\n\ngraph TB\t  subgraph 买炸鸡前   \t\t\t begin(出门)--&gt; buy[出门买炸鸡]    end    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack\n\n序列图(sequence diagram)概述sequenceDiagram \t[参与者1][消息线][参与者2]:消息体    ...\n\n\nsequenceDiagram 为每幅时序图的固定开头\n\nsequenceDiagram\t\tTitle: 买炸鸡    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸\n\n\n\nsequenceDiagram\t\tTitle: 买炸鸡    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸\n\n参与者（participant）传统时序图概念中参与者有角色和类对象之分，但这里我们不做此区分，用参与者表示一切参与交互的事物，可以是人、类对象、系统等形式。中间竖直的线段从上至下表示时间的流逝。\nsequenceDiagram    participant 参与者 1    participant 参与者 2    ...    participant 简称 as 参与者 3 #该语法可以在接下来的描述中使用简称来代替参与者 3\n\n\nparticipant &lt;参与者名称&gt; 声明参与者，语句次序即为参与者横向排列次序。\n\n消息线\n\n\n类型\n描述\n\n\n\n-&gt;\n无箭头的实线\n\n\n–&gt;\n无箭头的虚线\n\n\n-&gt;&gt;\n有箭头的实线（主动发出消息）\n\n\n–-&gt;&gt;\n有箭头的虚线（响应）\n\n\n-x\n末端为叉的实线（表示异步）\n\n\n–x\n末端为叉的虚线（表示异步）\n\n\n处理中-激活框从消息接收方的时间线上标记一小段时间，表示对消息进行处理的时间间隔。\n在消息线末尾增加 + ，则消息接收者进入当前消息的“处理中”状态；在消息线末尾增加 - ，则消息接收者离开当前消息的“处理中”状态。\nsequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller:给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！\n\nsequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller:给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！    \n\n注解（note）语法如下\nNote 位置表述 参与者: 标注文字\n\n其中位置表述可以为\n\n\n\n表述\n含义\n\n\n\nright of\n右侧\n\n\nleft of\n左侧\n\n\nover\n在当中，可以横跨多个参与者\n\n\nsequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    Note over 99,seller : 热爱炸鸡    Note left of 99 : 女    Note right of seller : 男    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller : 给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！\n\nsequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    Note over 99,seller : 热爱炸鸡    Note left of 99 : 女    Note right of seller : 男    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller : 给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！\n\n循环（loop）在条件满足时，重复发出消息序列。（相当于编程语言中的 while 语句。）\nsequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥       99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -&gt;&gt; +seller:给我炸！    loop 三分钟一次        99 -&gt;&gt; seller : 我的炸鸡好了吗？        seller --&gt;&gt; 99 : 正在炸    end    seller --&gt;&gt; -99: 您的炸鸡好了！\n\n\n\nsequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥       99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -&gt;&gt; +seller:给我炸！    loop 三分钟一次        99 -&gt;&gt; seller : 我的炸鸡好了吗？        seller --&gt;&gt; 99 : 正在炸    end    seller --&gt;&gt; -99: 您的炸鸡好了！\n\n选择（alt）在多个条件中作出判断，每个条件将对应不同的消息序列。（相当于 if 及 else if 语句。）\nsequenceDiagram        participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？    seller --&gt;&gt; 99 : 可卖的炸鸡数        alt 可卖的炸鸡数 &gt; 3        99 -&gt;&gt; seller : 买三只！    else 1 &lt; 可卖的炸鸡数 &lt; 3        99 -&gt;&gt; seller : 有多少买多少    else 可卖的炸鸡数 &lt; 1        99 -&gt;&gt; seller : 那我明天再来    end    seller --&gt;&gt; 99 : 欢迎下次光临\n\nsequenceDiagram        participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？    seller --&gt;&gt; 99 : 可卖的炸鸡数        alt 可卖的炸鸡数 &gt; 3        99 -&gt;&gt; seller : 买三只！    else 1 &lt; 可卖的炸鸡数 &lt; 3        99 -&gt;&gt; seller : 有多少买多少    else 可卖的炸鸡数 &lt; 1        99 -&gt;&gt; seller : 那我明天再来    end    seller --&gt;&gt; 99 : 欢迎下次光临\n\n可选（opt）在某条件满足时执行消息序列，否则不执行。相当于单个分支的 if 语句。\nsequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 买炸鸡    opt 全都卖完了        seller --&gt;&gt; 99 : 下次再来    end\n\n\n\nsequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 买炸鸡    opt 全都卖完了        seller --&gt;&gt; 99 : 下次再来    end\n\n并行（Par）将消息序列分成多个片段，这些片段并行执行。\nsequenceDiagram   participant 99 as 救救   participant seller as 炸鸡店小哥       99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！    par 并行执行        seller -&gt;&gt; seller : 装可乐    and        seller -&gt;&gt; seller : 炸炸鸡    end    seller --&gt;&gt; 99 : 您的炸鸡好了！\n\nsequenceDiagram   participant 99 as 救救   participant seller as 炸鸡店小哥       99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！    par 并行执行        seller -&gt;&gt; seller : 装可乐    and        seller -&gt;&gt; seller : 炸炸鸡    end    seller --&gt;&gt; 99 : 您的炸鸡好了！\n\n\n\n饼图（Pie）pie    title Pie Chart    &quot;Dogs&quot; : 386    &quot;Cats&quot; : 85    &quot;Rats&quot; : 150 \n\npie    title Pie Chart    &quot;Dogs&quot; : 386    &quot;Cats&quot; : 85    &quot;Rats&quot; : 150     &quot;panda&quot; : 200\n\n\n\n甘特图（gantt） title 标题dateFormat 日期格式section 部分名任务名:参数一, 参数二, 参数三, 参数四，参数五 //参数一：crit（是否重要，红框框） 或者 不填 //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态) //参数三：取小名 或者 不填 //参数四：任务开始时间 //参数五：任务结束时间\n\n\n官方教程\n\ngantt       dateFormat  YYYY-MM-DD       title Adding GANTT diagram functionality to mermaid       section A section       Completed task            :done,    des1, 2014-01-06,2014-01-08       Active task               :active,  des2, 2014-01-09, 3d       Future task               :         des3, after des2, 5d       Future task2              :         des4, after des3, 5d       section Critical tasks       Completed task in the critical line :crit, done, 2014-01-06,24h       Implement parser and jison          :crit, done, after des1, 2d       Create tests for parser             :crit, active, 3d       Future task in critical line        :crit, 5d       Create tests for renderer           :2d       Add to mermaid                      :1d       section Documentation       Describe gantt syntax               :active, a1, after des1, 3d       Add gantt diagram to demo page      :after a1  , 20h       Add another diagram to demo page    :doc1, after a1  , 48h       section Last section       Describe gantt syntax               :after doc1, 3d       Add gantt diagram to demo page      :20h       Add another diagram to demo page    :48h\n\ngantt       dateFormat  YYYY-MM-DD       title Adding GANTT diagram functionality to mermaid       section A section       Completed task            :done,    des1, 2014-01-06,2014-01-08       Active task               :active,  des2, 2014-01-09, 3d       Future task               :         des3, after des2, 5d       Future task2              :         des4, after des3, 5d       section Critical tasks       Completed task in the critical line :crit, done, 2014-01-06,24h       Implement parser and jison          :crit, done, after des1, 2d       Create tests for parser             :crit, active, 3d       Future task in critical line        :crit, 5d       Create tests for renderer           :2d       Add to mermaid                      :1d       section Documentation       Describe gantt syntax               :active, a1, after des1, 3d       Add gantt diagram to demo page      :after a1  , 20h       Add another diagram to demo page    :doc1, after a1  , 48h       section Last section       Describe gantt syntax               :after doc1, 3d       Add gantt diagram to demo page      :20h       Add another diagram to demo page    :48h\n\n\n\n\n","categories":["blog"],"tags":["Typora"]},{"title":"excel 第一讲 -- excel 入门","url":"/2021/04/09/tools/excel/excel-%E7%AC%AC%E4%B8%80%E8%AE%B2----excel-%E5%85%A5%E9%97%A8/","content":"excel 入门\nexcel详解\n\n基本操作基本概念excel 中每一个格子叫 单元格\n下一个单元格，enter  \n右一个，tab\n左一个，shift+tab\n键盘的上下左右键 可以更简单控制\n单元格宽度自适应\n\n要想让单元格宽度和文字长度一致，可以双击 F 和 G 之间的间隔线。\n合并后居中将整一行的单元格合并以后，将文字放在中间\n\n直接点击  菜单栏 –》 常用 –》 合并后居中 即可。  \n其他各种颜色，字体等等，都可以在这里找到。\n将所有栏位宽度（高度）调整为一致框选所有想要相同宽度的单元格，之后选中其中任何一个间隔线 拖动到想要宽度，之后所有单元格宽度都会一致。\n列高 的操作也同样适用\n\n产生等差（等比）数列将鼠标移动到 T002 右下角，变成 + 后，往下拖动。可以自动生成数列。\n等差，等比数列 也可以。\n\n\n日期设置excel 默认的日期格式以 / 作为分隔，方便进行后期的各种日期格式转换。例如   2021/04/09 。\n输入完成以后，右键日期，可以进行各种格式的调整。\n\n如果出现全部都是 ######## 符号。 原因是长度超过了单元格的长度。\n可以双击右侧的分隔线，自适应内容长度，即可解决问题。\n快捷键：\ncontrol  ;  \n\n即可自动产生默认日期。  2021/04/09\n\n当然也可以 拉住右下角往下拖, 来实现自动补充。并且可以进行如下选择。\n\n\n计算\n如上图所示，想要进行乘法计算，只需要在 总金额处：\n\n写一个 = 符号\n鼠标左键单击 45 所在的单元格\n鼠标左键单击 30 所在的单元格\n回车\n\n如果要进行公式的修改，双击单元格，或者 到上方的编辑页直接编辑。\nexcel 进行的复制，是计算公式的复制，不只是值的复制\n\n当然，也可以通过拖拉右下角来实现整列的计算。\n价格的设置选择整一列以后，在  菜单 –》 常规 中选择 货币，就可以将数字转变成货币形式。\n\n同时可以根据自己需求，进行小数位数减少等的操作。\n左上角有个小刷子（我的截图最左上角从上往下第三个），可以复制格式。选择了以后，选中其他的金额列就可以复制格式了\n表格设计表格边框如果在打印中，没有表格线，框。可以有两个方法\n默认表格形式页面布局 –》 网格线 –》 打印  中的打勾，即可打印出表格边框。\n自定义表格形式\n关闭上面的 打印中的打勾。\n开始（常用） –》边框选择 –》 线条颜色 ，线型\n这时候，鼠标会变成画笔，可以 画横线，或者竖线，或者画框（只有外框）。\n开始 –》 边框选择 –》 绘制边框网络  ，选择后，画笔会画出框以及内部所有网格。\n按住 shift不放，会变成橡皮擦，可以擦除格式。\nesc 退出画笔功能。\n还有另一种方式，是先选择范围，再进行边框的选择，和 开始 –》 边框选择 –》 上下框线  基本类似\n\n\n表格背景图片背景图片无法打印出来，但是能提高表格的美观程度\n\n页面布局 –》 背景  中可以选择。\n\n图片中存在的网格线，可以通过如下去除：页面布局 –》 网格线 –》 查看 ，把 √ 去掉。\n\n如果有字部分因为图片原因难以辨认，可以先框选表格部分， 开始 –》 油漆桶 –》 选个白色即可。\n\n选择 A 列，右键，选择插入，可以在右侧插入一列，更加美观。\n\n框选一部分以后， 开始 –》 油漆桶 –》 无填充 ，又可以显示背景图片。选择颜色，就又可以覆盖。\n\n最终结果如下\n\n\n\n冻结窗格\n有时需要将表头冻结，使其在滚轮下滑时，固定在第一行\n\n首先选中需要冻结的行的下一行\n\n视图 –》 冻结窗格 ，即可冻结自己所想的那一行。\n\n同时也能冻结列，同理，选择想要冻结的右一行，选择 冻结窗格即可。\n\n\n分割视窗\n分割视窗，常用来进行 **上下跨度比较大 ** 的两列之间的比较。比如 1月和 12月 的数据距离比较远，想资料比对，可以通过这个实现。\n选中想要分割的 下一行，视图 –》 拆分\n之后，上下两部分可以独立滚动。\n如果将 分割线拖到表格最上方，就可以关闭 拆分功能。\n\n\n套用表格格式类似于word， excel有更强大的转化为表格的方法。\n第一种，直接格式化\n开始 –》 套用表格格式。\n直接对表格样式进行更改。\n\n第二种，用表格化\n框选想要 修改表格的区域。\n插入 –》 表格\n会跳到 表格栏，便可以选择自己喜欢的样式。\n镶边行，镶边列 等都可以设置。\n如果觉得颜色不够多，可以到  页面布局 –》 颜色  。 整个表格都会变化颜色。\n表格中的 汇总行 ，会将最后一列值相加。 可以拖动右下角，往左边拖，使每一列都计算出汇总数据。\n同时对每一列的计算，都可以选择不同的计算公式。见下图\n\n\n\n表格新增一行 ：在上一行选中一个单元格，按 tab 键可以新增一空白行\n\n表格新增一列：在标题同一行新增一个单元格，回车即可。\n\n清除所有样式：只要 表格 –》 选择样式处 –》 第一个无样式。  \n\n退出表格模式：表格 –》 转换为区域 ，  即可变成原始状态。\n\n\n数据分析排序默认排序\n选中想要排序的列 中的某一个单元格\n开始 –》 排序和筛选 –》 升序 ， 即可升序排序\n排序存在的问题：不能简单框选，然后进行排序。 可能会只排序那一列，其他几列没有排序，导致 各个月份的数据出现错乱。\n所以不要框选整栏的资料\n如果要进行多列的排序，则 先选择一个单元格\n开始 –》 排序和筛选 –》 自定义排序 ，可以增加多列来进行排序。\n\n自定义排序\n根据自己定义的顺序来进行排序 ，常 用于中文等的排序\n开始 –》 排序和筛选 –》 自定义排序 –》 顺序 –》 自定义列表  \n按需加入，就可以进行排序。\n在第二步中的自定列表中，可以看到已经有部分值。\n用处是， 在单元格中输入 一月 以后，按住右下角往下拉，可以出来已经配置的值。\n!!所以可以自定义所需的值，到时候往下拉，就可以出来该顺序的值。\n\n筛选普通筛选可以隐藏不满足条件的数据。只显示满足条件的数据。\n\n开始 –》 排序和筛选 –》 筛选 。\n在每一列的表头就出现 向下的箭头，可以选择想要筛选的数据。\n模糊筛选：   每一列表头的筛选中 –》   开头是  ， 就可以进行文字的筛选。\n对数字 进行 高于，小于，介于  等的筛选也是可以。\n取 前几项， 个数，百分比 也可以。\n日期筛选 也有特定的筛选器，可以选择 某个日期之后，上个月，这一季 都可以。\n色彩排序： 按住 ctrl（command），选择几个单元格 –》 油漆桶，选择喜欢的颜色。 –》 排序下箭头 –》 按颜色排序 。\n色彩筛选当然，也可以对上一步中的 色彩进行筛选。\n\n切片器切片器，就是强化版的筛选。\n\n在表格 –》 插入切片器 。选择想要生成的列的切片器。\n多选几个后，会生成多个框。\n点击其中的 栏目，可以快速进行筛选。\n多选条件也是可以，按住 ctrl键不放，可以选择多个条件。\n\n\n\n去除切片器：删除即可。\n\n条件格式筛选会将不符合条件的隐藏。\n条件格式，会用特殊颜色来显示筛选结果。\n\n选定一列\n开始 –》 条件格式 –》 突出显示单元格规则 –》 等于 –》 输入一个值（或者直接用鼠标点击一个单元格作为条件）。\n符合条件的值便会高亮。\n日期，介于 等等条件，也是相同方法。\n开始 –》 条件格式 –》   数据条 色阶 图标集 也可以更明显的显示数据的大小，各个规则也可以自定义。如下是数据条。\n\n\n\n清除规则：  开始 –》 条件格式 –》 清除规则 –》 清除整张表的规则 。可以还原所有信息。\n\n公式设定工作表excel 最大的特点，就是一个excel文件内可以有多个工作表\n基本操作\n复制工作表：  按住ctrl ，鼠标左键拖动便可以复制。\n上述复制工作表也可以在不同的excel 之间复制。  工作表上–》右键 –》 移动或复制 –》 选择目标excel –》 建立副本。\n\n工作表群组 同时操作多张工作表的内容和格式。\n群组基本操作\n按住ctrl，选择多张工作表\n修改样式，会同步修改所有群组中的工作表\n退出群组： 右键某一张工作表 –》 取消工作表群组。\n隐藏：上述方法，右键之后，也可以隐藏，取消隐藏。\n\n合并计算\n可以将多张工作表内容合并，计算到同一张工作表。\n数据  –》  合并计算 –》 函数（选择求和） –》 引用（点击具体的表，框选内容） –》 点击 + 号 新增 –》 如果有标题栏 等，可以选择最下面的 首行,最左列 –》 确定，即可将数据汇总。\n上述步骤中，选择 创建指向源数据的链接 ，会在表格最左侧显示 + 号，可以查看是从哪张表格来源。\n常常用于不同月份，不同年份的合计。\n\n图表表格转成图表\n基本方法\n选中表格，包含 行头,列头 , 因为他们可以作为坐标轴文字。\n\n创建图表：插入 –》 建议的图表。\n\n图表移动到新的工作表： 图表设计 –》 移动图表\n\n图表内新增文字等项目：  图表设计 –》 添加图表元素 。 可以加入 坐标轴标题 等等。\n\n纵坐标轴标题竖排：右键标题 –》 设置坐标轴标题格式 –》 文本选项–》 文字效果 –》 文字方向 –》 竖排\n\n表格与图表同步：新增数据 –》 拖动单元格右下角 –》 使图标内容包含整个表格 。 当然也可以进行筛选。\n\n更改图标样式：图标设计 –》 更改图标类型 。    \n\n切换行列：图标设计 –》 切换行/列。   \n\n\n中级表\n横（纵）坐标的范围更改：坐标轴上右键 –》 设置纵坐标格式。  可以设置最大，最小值，主刻度，次要刻度等\n用图片替代直方图：直方图上右键 –》 设置数据列格式 –》 油漆桶 –》 图片或纹理填充（可以用自己的图片）。\n饼图：ctrl选中多块区域 –》 插入 –》 饼图\n饼图中添加说明： 图表设计 –》 添加图表元素 –》 数据标签 –》 数据标签外 。 或者直接右边的 + 号。\n饼图区块移出：双击选中某一块饼 –》 移除–》 设置阴影等。\n折线图：插入 –》 折线图。\n折线走势图（迷你图）：选中表格最右边空白栏位 –》 插入 –》 迷你图 –》 框选表格中数据 –》 确定。可以显示迷你折线图。\n\n\n\n迷你图样式修改：迷你图 –》 设置柱形等，颜色等。\n删除迷你图：迷你图 –》 清除\n散点图：选中数据 –》 插入 –》 散点图 –》 右上角+号 –》 趋势图\n雷达图，组合图 等，用法都类似。\n\n数据透视表\n选中一个单元格 –》 插入 –》 数据透视表\n\n可以排序，筛选\n\n可以将栏目直接拖拉到 筛选栏等里面。\n\n数据透视表 == 积木玩具，可以根据自己想要的来操作。\n\n单元格可以组成群组\n\n各个栏目都可以重命名\n\n数据透视图 ：数据透视表分析 –》 数据透视图\n\n数据同步：原始表格更新了数据，需要同步数据：  数据透视表分析 –》 刷新\n\n自动同步：表格创建时候，即为动态表格： 框选所有数据 –》 开始 –》 套用表格格式 –》 选择其中一个即可。\n\n\n打印设定分页设定\n查看打印的分页：视图 –》 分页预览 。 虚线是分页线\n调整分页：选中分页线 –》 拖拉即可。  可以水平拉（将最后一列总计放到正常页面中），可以竖直拉（按照月份来分页打印）。\n手动插入（移除）分页：页面布局 –》 分隔符 –》 插入（移除）分页。\n标题列在每一页中都显示：页面布局–》 打印标题 –》 顶端标题行 –》 选择标题行。\n上述是第一种方式，下面是第二种方式\n调整页面大小：页面布局 –》 宽度（高度，缩放比？）\n打印特定行：页面布局 –》 打印区域 –》 设置打印区域（清除）\n\n页眉页脚，水印\n查看 页眉，页脚  ：  视图–》页面布局 。  每一个都分为 左中右 三个区块。\n添加页码：选中页脚的右方格 –》 页眉和页脚–》 页码 –》 在旁边可以输入文字，比如 第   页 –》 就会显示 第一页\n添加总页数：选中页脚有方格 –》 页眉和页脚 –》 页数 –》 添加文字 –》 第1页/共4页\n页尾模板：页眉和页脚 –》 页尾 –》 选择模板\n可以插入图片：页眉和页脚 –》 图片 –》 调整大小 –》 设定百分比\n水印：空白工作表 –》 插入 –》 A（文字） –》 输入想要的文字（比如：机密） –》 调整文字大小，倾斜 –》 保存到 ppt 或者 word –》 保存成图片 –》 选中页眉中间框 –》 插入图片 –》 调整图片大小 和 刷淡 –》 最后成功。\n\n函数最基本的整列计算相加\n开始 –》 自动求和  按钮，会自动猜测要相加的范围，生成表达式\n也可以用鼠标自己来选择想要框选的范围。\n也可以按住 ctrl 不放来选择多个范围。\nenter 键即可进行计算\n其余的 平均值，最小值，最大值 等，与其基本类似\n\n下一节介绍复杂函数","categories":["tools"],"tags":["excel"]},{"title":"netty 第一讲 -- NIO 基础","url":"/2021/04/02/java/netty/Netty01-nio/","content":"netty 第一讲\n一. NIO 基础non-blocking io 非阻塞 IO\n1. 三大组件1.1 Channel &amp; Bufferchannel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层\ngraph LRchannel --&gt; bufferbuffer --&gt; channel\n\n常见的 Channel 有\n\nFileChannel\nDatagramChannel\nSocketChannel\nServerSocketChannel\n\nbuffer 则用来缓冲读写数据，常见的 buffer 有\n\nByteBuffer\nMappedByteBuffer\nDirectByteBuffer\nHeapByteBuffer\n\n\nShortBuffer\nIntBuffer\nLongBuffer\nFloatBuffer\nDoubleBuffer\nCharBuffer\n\n1.2 Selectorselector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途\n多线程版设计graph TDsubgraph 多线程版t1(thread) --&gt; s1(socket1)t2(thread) --&gt; s2(socket2)t3(thread) --&gt; s3(socket3)end\n⚠️ 多线程版缺点\n内存占用高\n线程上下文切换成本高\n只适合连接数少的场景\n\n线程池版设计graph TDsubgraph 线程池版t4(thread) --&gt; s4(socket1)t5(thread) --&gt; s5(socket2)t4(thread) -.-&gt; s6(socket3)t5(thread) -.-&gt; s7(socket4)end\n⚠️ 线程池版缺点\n阻塞模式下，线程仅能处理一个 socket 连接\n仅适合短连接场景\n\nselector 版设计selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）\ngraph TDsubgraph selector 版thread --&gt; selectorselector --&gt; c1(channel)selector --&gt; c2(channel)selector --&gt; c3(channel)end\n\n\n\n调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理\n2. ByteBuffer有一普通文本文件 data.txt，内容为\n1234567890abcd\n\n使用 FileChannel 来读取文件内容\n@Slf4jpublic class ChannelDemo1 &#123;    public static void main(String[] args) &#123;        try (RandomAccessFile file = new RandomAccessFile(&quot;helloword/data.txt&quot;, &quot;rw&quot;)) &#123;            FileChannel channel = file.getChannel();            ByteBuffer buffer = ByteBuffer.allocate(10);            do &#123;                // 向 buffer 写入                int len = channel.read(buffer);                log.debug(&quot;读到字节数：&#123;&#125;&quot;, len);                if (len == -1) &#123;                    break;                &#125;                // 切换 buffer 读模式                buffer.flip();                while(buffer.hasRemaining()) &#123;                    log.debug(&quot;&#123;&#125;&quot;, (char)buffer.get());                &#125;                // 切换 buffer 写模式                buffer.clear();            &#125; while (true);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n输出\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：1010:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 110:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 210:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 310:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 410:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 510:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 610:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 710:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 810:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 910:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 010:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：410:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1\n\n\n\n2.1  ByteBuffer 正确使用姿势\n向 buffer 写入数据，例如调用 channel.read(buffer)\n调用 flip() 切换至读模式\n从 buffer 读取数据，例如调用 buffer.get()\n调用 clear() 或 compact() 切换至写模式\n重复 1~4 步骤\n\n2.2 ByteBuffer 结构ByteBuffer 有以下重要属性\n\ncapacity\nposition\nlimit\n\n一开始\n\n写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态\n\nflip 动作发生后，position 切换为读取位置，limit 切换为读取限制\n\n读取 4 个字节后，状态\n\nclear 动作发生后，状态\n\ncompact 方法，是把未读完的部分向前压缩，然后切换至写模式\n\n💡 调试工具类public class ByteBufferUtil &#123;    private static final char[] BYTE2CHAR = new char[256];    private static final char[] HEXDUMP_TABLE = new char[256 * 4];    private static final String[] HEXPADDING = new String[16];    private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 &gt;&gt;&gt; 4];    private static final String[] BYTE2HEX = new String[256];    private static final String[] BYTEPADDING = new String[16];    static &#123;        final char[] DIGITS = &quot;0123456789abcdef&quot;.toCharArray();        for (int i = 0; i &lt; 256; i++) &#123;            HEXDUMP_TABLE[i &lt;&lt; 1] = DIGITS[i &gt;&gt;&gt; 4 &amp; 0x0F];            HEXDUMP_TABLE[(i &lt;&lt; 1) + 1] = DIGITS[i &amp; 0x0F];        &#125;        int i;        // Generate the lookup table for hex dump paddings        for (i = 0; i &lt; HEXPADDING.length; i++) &#123;            int padding = HEXPADDING.length - i;            StringBuilder buf = new StringBuilder(padding * 3);            for (int j = 0; j &lt; padding; j++) &#123;                buf.append(&quot;   &quot;);            &#125;            HEXPADDING[i] = buf.toString();        &#125;        // Generate the lookup table for the start-offset header in each row (up to 64KiB).        for (i = 0; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;            StringBuilder buf = new StringBuilder(12);            buf.append(NEWLINE);            buf.append(Long.toHexString(i &lt;&lt; 4 &amp; 0xFFFFFFFFL | 0x100000000L));            buf.setCharAt(buf.length() - 9, &#x27;|&#x27;);            buf.append(&#x27;|&#x27;);            HEXDUMP_ROWPREFIXES[i] = buf.toString();        &#125;        // Generate the lookup table for byte-to-hex-dump conversion        for (i = 0; i &lt; BYTE2HEX.length; i++) &#123;            BYTE2HEX[i] = &#x27; &#x27; + StringUtil.byteToHexStringPadded(i);        &#125;        // Generate the lookup table for byte dump paddings        for (i = 0; i &lt; BYTEPADDING.length; i++) &#123;            int padding = BYTEPADDING.length - i;            StringBuilder buf = new StringBuilder(padding);            for (int j = 0; j &lt; padding; j++) &#123;                buf.append(&#x27; &#x27;);            &#125;            BYTEPADDING[i] = buf.toString();        &#125;        // Generate the lookup table for byte-to-char conversion        for (i = 0; i &lt; BYTE2CHAR.length; i++) &#123;            if (i &lt;= 0x1f || i &gt;= 0x7f) &#123;                BYTE2CHAR[i] = &#x27;.&#x27;;            &#125; else &#123;                BYTE2CHAR[i] = (char) i;            &#125;        &#125;    &#125;    /**     * 打印所有内容     * @param buffer     */    public static void debugAll(ByteBuffer buffer) &#123;        int oldlimit = buffer.limit();        buffer.limit(buffer.capacity());        StringBuilder origin = new StringBuilder(256);        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());        System.out.println(&quot;+--------+-------------------- all ------------------------+----------------+&quot;);        System.out.printf(&quot;position: [%d], limit: [%d]\\n&quot;, buffer.position(), oldlimit);        System.out.println(origin);        buffer.limit(oldlimit);    &#125;    /**     * 打印可读取内容     * @param buffer     */    public static void debugRead(ByteBuffer buffer) &#123;        StringBuilder builder = new StringBuilder(256);        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());        System.out.println(&quot;+--------+-------------------- read -----------------------+----------------+&quot;);        System.out.printf(&quot;position: [%d], limit: [%d]\\n&quot;, buffer.position(), buffer.limit());        System.out.println(builder);    &#125;    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) &#123;        if (isOutOfBounds(offset, length, buf.capacity())) &#123;            throw new IndexOutOfBoundsException(                    &quot;expected: &quot; + &quot;0 &lt;= offset(&quot; + offset + &quot;) &lt;= offset + length(&quot; + length                            + &quot;) &lt;= &quot; + &quot;buf.capacity(&quot; + buf.capacity() + &#x27;)&#x27;);        &#125;        if (length == 0) &#123;            return;        &#125;        dump.append(                &quot;         +-------------------------------------------------+&quot; +                        NEWLINE + &quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot; +                        NEWLINE + &quot;+--------+-------------------------------------------------+----------------+&quot;);        final int startIndex = offset;        final int fullRows = length &gt;&gt;&gt; 4;        final int remainder = length &amp; 0xF;        // Dump the rows which have 16 bytes.        for (int row = 0; row &lt; fullRows; row++) &#123;            int rowStartIndex = (row &lt;&lt; 4) + startIndex;            // Per-row prefix.            appendHexDumpRowPrefix(dump, row, rowStartIndex);            // Hex dump            int rowEndIndex = rowStartIndex + 16;            for (int j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);            &#125;            dump.append(&quot; |&quot;);            // ASCII dump            for (int j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);            &#125;            dump.append(&#x27;|&#x27;);        &#125;        // Dump the last row which has less than 16 bytes.        if (remainder != 0) &#123;            int rowStartIndex = (fullRows &lt;&lt; 4) + startIndex;            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);            // Hex dump            int rowEndIndex = rowStartIndex + remainder;            for (int j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);            &#125;            dump.append(HEXPADDING[remainder]);            dump.append(&quot; |&quot;);            // Ascii dump            for (int j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);            &#125;            dump.append(BYTEPADDING[remainder]);            dump.append(&#x27;|&#x27;);        &#125;        dump.append(NEWLINE +                &quot;+--------+-------------------------------------------------+----------------+&quot;);    &#125;    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) &#123;        if (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;            dump.append(HEXDUMP_ROWPREFIXES[row]);        &#125; else &#123;            dump.append(NEWLINE);            dump.append(Long.toHexString(rowStartIndex &amp; 0xFFFFFFFFL | 0x100000000L));            dump.setCharAt(dump.length() - 9, &#x27;|&#x27;);            dump.append(&#x27;|&#x27;);        &#125;    &#125;    public static short getUnsignedByte(ByteBuffer buffer, int index) &#123;        return (short) (buffer.get(index) &amp; 0xFF);    &#125;&#125;\n\n\n\n2.3 ByteBuffer 常见方法分配空间可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法\nBytebuffer buf = ByteBuffer.allocate(16);\n\n\n\n向 buffer 写入数据有两种办法\n\n调用 channel 的 read 方法\n调用 buffer 自己的 put 方法\n\nint readBytes = channel.read(buf);\n\n和\nbuf.put((byte)127);\n\n\n\n从 buffer 读取数据同样有两种办法\n\n调用 channel 的 write 方法\n调用 buffer 自己的 get 方法\n\nint writeBytes = channel.write(buf);\n\n和\nbyte b = buf.get();\n\nget 方法会让 position 读指针向后走，如果想重复读取数据\n\n可以调用 rewind 方法将 position 重新置为 0\n或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针\n\nmark 和 resetmark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置\n\n注意\nrewind 和 flip 都会清除 mark 位置\n\n字符串与 ByteBuffer 互转ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(&quot;你好&quot;);ByteBuffer buffer2 = Charset.forName(&quot;utf-8&quot;).encode(&quot;你好&quot;);debug(buffer1);debug(buffer2);CharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);System.out.println(buffer3.getClass());System.out.println(buffer3.toString());\n\n输出\n         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| e4 bd a0 e5 a5 bd                               |......          |+--------+-------------------------------------------------+----------------+         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| e4 bd a0 e5 a5 bd                               |......          |+--------+-------------------------------------------------+----------------+class java.nio.HeapCharBuffer你好\n\n\n\n⚠️ Buffer 的线程安全\nBuffer 是非线程安全的\n\n2.4 Scattering Reads分散读取，有一个文本文件 3parts.txt\nonetwothree\n\n使用如下方式读取，可以将数据填充至多个 buffer\ntry (RandomAccessFile file = new RandomAccessFile(&quot;helloword/3parts.txt&quot;, &quot;rw&quot;)) &#123;    FileChannel channel = file.getChannel();    ByteBuffer a = ByteBuffer.allocate(3);    ByteBuffer b = ByteBuffer.allocate(3);    ByteBuffer c = ByteBuffer.allocate(5);    channel.read(new ByteBuffer[]&#123;a, b, c&#125;);    a.flip();    b.flip();    c.flip();    debug(a);    debug(b);    debug(c);&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;\n\n结果\n         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 6f 6e 65                                        |one             |+--------+-------------------------------------------------+----------------+         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 74 77 6f                                        |two             |+--------+-------------------------------------------------+----------------+         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 74 68 72 65 65                                  |three           |+--------+-------------------------------------------------+----------------+\n\n\n\n2.5 Gathering Writes使用如下方式写入，可以将多个 buffer 的数据填充至 channel\ntry (RandomAccessFile file = new RandomAccessFile(&quot;helloword/3parts.txt&quot;, &quot;rw&quot;)) &#123;    FileChannel channel = file.getChannel();    ByteBuffer d = ByteBuffer.allocate(4);    ByteBuffer e = ByteBuffer.allocate(4);    channel.position(11);    d.put(new byte[]&#123;&#x27;f&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;r&#x27;&#125;);    e.put(new byte[]&#123;&#x27;f&#x27;, &#x27;i&#x27;, &#x27;v&#x27;, &#x27;e&#x27;&#125;);    d.flip();    e.flip();    debug(d);    debug(e);    channel.write(new ByteBuffer[]&#123;d, e&#125;);&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;\n\n输出\n         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 66 6f 75 72                                     |four            |+--------+-------------------------------------------------+----------------+         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 66 69 76 65                                     |five            |+--------+-------------------------------------------------+----------------+\n\n文件内容\nonetwothreefourfive\n\n\n\n2.6 练习网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\n\nHello,world\\n\nI’m zhangsan\\n\nHow are you?\\n\n\n变成了下面的两个 byteBuffer (黏包，半包)\n\nHello,world\\nI’m zhangsan\\nHo\nw are you?\\n\n\n现在要求你编写程序，将错乱的数据恢复成原始的按 \\n 分隔的数据\npublic static void main(String[] args) &#123;    ByteBuffer source = ByteBuffer.allocate(32);    //                     11            24    source.put(&quot;Hello,world\\nI&#x27;m zhangsan\\nHo&quot;.getBytes());    split(source);    source.put(&quot;w are you?\\nhaha!\\n&quot;.getBytes());    split(source);&#125;private static void split(ByteBuffer source) &#123;    source.flip();    int oldLimit = source.limit();    for (int i = 0; i &lt; oldLimit; i++) &#123;        if (source.get(i) == &#x27;\\n&#x27;) &#123;            System.out.println(i);            ByteBuffer target = ByteBuffer.allocate(i + 1 - source.position());            // 0 ~ limit            source.limit(i + 1);            target.put(source); // 从source 读，向 target 写            debugAll(target);            source.limit(oldLimit);        &#125;    &#125;    source.compact();&#125;\n\n\n\n3. 文件编程3.1 FileChannel⚠️ FileChannel 工作模式\nFileChannel 只能工作在阻塞模式下\n\n获取不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法\n\n通过 FileInputStream 获取的 channel 只能读\n通过 FileOutputStream 获取的 channel 只能写\n通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定\n\n读取会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾\nint readBytes = channel.read(buffer);\n\n\n\n写入写入的正确姿势如下， SocketChannel\nByteBuffer buffer = ...;buffer.put(...); // 存入数据buffer.flip();   // 切换读模式while(buffer.hasRemaining()) &#123;    channel.write(buffer);&#125;\n\n在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel\n关闭channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法\n位置获取当前位置\nlong pos = channel.position();\n\n设置当前位置\nlong newPos = ...;channel.position(newPos);\n\n设置当前位置时，如果设置为文件的末尾\n\n这时读取会返回 -1 \n这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）\n\n大小使用 size 方法获取文件的大小\n强制写入操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘\n3.2 两个 Channel 传输数据String FROM = &quot;helloword/data.txt&quot;;String TO = &quot;helloword/to.txt&quot;;long start = System.nanoTime();try (FileChannel from = new FileInputStream(FROM).getChannel();     FileChannel to = new FileOutputStream(TO).getChannel();    ) &#123;    from.transferTo(0, from.size(), to);&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;long end = System.nanoTime();System.out.println(&quot;transferTo 用时：&quot; + (end - start) / 1000_000.0);\n\n输出\ntransferTo 用时：8.2011\n\n\n\n超过 2g 大小的文件传输\npublic class TestFileChannelTransferTo &#123;    public static void main(String[] args) &#123;        try (                FileChannel from = new FileInputStream(&quot;data.txt&quot;).getChannel();                FileChannel to = new FileOutputStream(&quot;to.txt&quot;).getChannel();        ) &#123;            // 效率高，底层会利用操作系统的零拷贝进行优化            long size = from.size();            // left 变量代表还剩余多少字节            for (long left = size; left &gt; 0; ) &#123;                System.out.println(&quot;position:&quot; + (size - left) + &quot; left:&quot; + left);                left -= from.transferTo((size - left), left, to);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n实际传输一个超大文件\nposition:0 left:7769948160position:2147483647 left:5622464513position:4294967294 left:3474980866position:6442450941 left:1327497219\n\n\n\n3.3 Pathjdk7 引入了 Path 和 Paths 类\n\nPath 用来表示文件路径\nPaths 是工具类，用来获取 Path 实例\n\nPath source = Paths.get(&quot;1.txt&quot;); // 相对路径 使用 user.dir 环境变量来定位 1.txtPath source = Paths.get(&quot;d:\\\\1.txt&quot;); // 绝对路径 代表了  d:\\1.txtPath source = Paths.get(&quot;d:/1.txt&quot;); // 绝对路径 同样代表了  d:\\1.txtPath projects = Paths.get(&quot;d:\\\\data&quot;, &quot;projects&quot;); // 代表了  d:\\data\\projects\n\n\n. 代表了当前路径\n.. 代表了上一级路径\n\n例如目录结构如下\nd:\t|- data\t\t|- projects\t\t\t|- a\t\t\t|- b\n\n代码\nPath path = Paths.get(&quot;d:\\\\data\\\\projects\\\\a\\\\..\\\\b&quot;);System.out.println(path);System.out.println(path.normalize()); // 正常化路径\n\n会输出\nd:\\data\\projects\\a\\..\\bd:\\data\\projects\\b\n\n\n\n3.4 Files检查文件是否存在\nPath path = Paths.get(&quot;helloword/data.txt&quot;);System.out.println(Files.exists(path));\n\n\n\n创建一级目录\nPath path = Paths.get(&quot;helloword/d1&quot;);Files.createDirectory(path);\n\n\n如果目录已存在，会抛异常 FileAlreadyExistsException\n不能一次创建多级目录，否则会抛异常 NoSuchFileException\n\n创建多级目录用\nPath path = Paths.get(&quot;helloword/d1/d2&quot;);Files.createDirectories(path);\n\n\n\n拷贝文件\nPath source = Paths.get(&quot;helloword/data.txt&quot;);Path target = Paths.get(&quot;helloword/target.txt&quot;);Files.copy(source, target);\n\n\n如果文件已存在，会抛异常 FileAlreadyExistsException\n\n如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n\n\n\n移动文件\nPath source = Paths.get(&quot;helloword/data.txt&quot;);Path target = Paths.get(&quot;helloword/data.txt&quot;);Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);\n\n\nStandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性\n\n删除文件\nPath target = Paths.get(&quot;helloword/target.txt&quot;);Files.delete(target);\n\n\n如果文件不存在，会抛异常 NoSuchFileException\n\n删除目录\nPath target = Paths.get(&quot;helloword/d1&quot;);Files.delete(target);\n\n\n如果目录还有内容，会抛异常 DirectoryNotEmptyException\n\n遍历目录文件\npublic static void main(String[] args) throws IOException &#123;    Path path = Paths.get(&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91&quot;);    AtomicInteger dirCount = new AtomicInteger();    AtomicInteger fileCount = new AtomicInteger();    Files.walkFileTree(path, new SimpleFileVisitor&lt;Path&gt;()&#123;        @Override        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)             throws IOException &#123;            System.out.println(dir);            dirCount.incrementAndGet();            return super.preVisitDirectory(dir, attrs);        &#125;        @Override        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)             throws IOException &#123;            System.out.println(file);            fileCount.incrementAndGet();            return super.visitFile(file, attrs);        &#125;    &#125;);    System.out.println(dirCount); // 133    System.out.println(fileCount); // 1479&#125;\n\n\n\n统计 jar 的数目\nPath path = Paths.get(&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91&quot;);AtomicInteger fileCount = new AtomicInteger();Files.walkFileTree(path, new SimpleFileVisitor&lt;Path&gt;()&#123;    @Override    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)         throws IOException &#123;        if (file.toFile().getName().endsWith(&quot;.jar&quot;)) &#123;            fileCount.incrementAndGet();        &#125;        return super.visitFile(file, attrs);    &#125;&#125;);System.out.println(fileCount); // 724\n\n\n\n删除多级目录\nPath path = Paths.get(&quot;d:\\\\a&quot;);Files.walkFileTree(path, new SimpleFileVisitor&lt;Path&gt;()&#123;    @Override    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)         throws IOException &#123;        Files.delete(file);        return super.visitFile(file, attrs);    &#125;    @Override    public FileVisitResult postVisitDirectory(Path dir, IOException exc)         throws IOException &#123;        Files.delete(dir);        return super.postVisitDirectory(dir, exc);    &#125;&#125;);\n\n\n\n⚠️ 删除很危险\n删除是危险操作，确保要递归删除的文件夹没有重要内容\n\n拷贝多级目录\nlong start = System.currentTimeMillis();String source = &quot;D:\\\\Snipaste-1.16.2-x64&quot;;String target = &quot;D:\\\\Snipaste-1.16.2-x64aaa&quot;;Files.walk(Paths.get(source)).forEach(path -&gt; &#123;    try &#123;        String targetName = path.toString().replace(source, target);        // 是目录        if (Files.isDirectory(path)) &#123;            Files.createDirectory(Paths.get(targetName));        &#125;        // 是普通文件        else if (Files.isRegularFile(path)) &#123;            Files.copy(path, Paths.get(targetName));        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;);long end = System.currentTimeMillis();System.out.println(end - start);\n\n\n\n\n\n4. 网络编程4.1 非阻塞 vs 阻塞阻塞\n阻塞模式下，相关方法都会导致线程暂停\nServerSocketChannel.accept 会在没有连接建立时让线程暂停\nSocketChannel.read 会在没有数据可读时让线程暂停\n阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置\n\n\n单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持\n但多线程下，有新的问题，体现在以下方面\n32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低\n可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接\n\n\n\n服务器端\n// 使用 nio 来理解阻塞模式, 单线程// 0. ByteBufferByteBuffer buffer = ByteBuffer.allocate(16);// 1. 创建了服务器ServerSocketChannel ssc = ServerSocketChannel.open();// 2. 绑定监听端口ssc.bind(new InetSocketAddress(8080));// 3. 连接集合List&lt;SocketChannel&gt; channels = new ArrayList&lt;&gt;();while (true) &#123;    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信    log.debug(&quot;connecting...&quot;);    SocketChannel sc = ssc.accept(); // 阻塞方法，线程停止运行    log.debug(&quot;connected... &#123;&#125;&quot;, sc);    channels.add(sc);    for (SocketChannel channel : channels) &#123;        // 5. 接收客户端发送的数据        log.debug(&quot;before read... &#123;&#125;&quot;, channel);        channel.read(buffer); // 阻塞方法，线程停止运行        buffer.flip();        debugRead(buffer);        buffer.clear();        log.debug(&quot;after read...&#123;&#125;&quot;, channel);    &#125;&#125;\n\n客户端\nSocketChannel sc = SocketChannel.open();sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));System.out.println(&quot;waiting...&quot;);\n\n\n\n非阻塞\n非阻塞模式下，相关方法都会不会让线程暂停\n在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行\nSocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept \n写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去\n\n\n但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu\n数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）\n\n服务器端，客户端代码不变\n// 使用 nio 来理解非阻塞模式, 单线程// 0. ByteBufferByteBuffer buffer = ByteBuffer.allocate(16);// 1. 创建了服务器ServerSocketChannel ssc = ServerSocketChannel.open();ssc.configureBlocking(false); // 非阻塞模式// 2. 绑定监听端口ssc.bind(new InetSocketAddress(8080));// 3. 连接集合List&lt;SocketChannel&gt; channels = new ArrayList&lt;&gt;();while (true) &#123;    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信    SocketChannel sc = ssc.accept(); // 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null    if (sc != null) &#123;        log.debug(&quot;connected... &#123;&#125;&quot;, sc);        sc.configureBlocking(false); // 非阻塞模式        channels.add(sc);    &#125;    for (SocketChannel channel : channels) &#123;        // 5. 接收客户端发送的数据        int read = channel.read(buffer);// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0        if (read &gt; 0) &#123;            buffer.flip();            debugRead(buffer);            buffer.clear();            log.debug(&quot;after read...&#123;&#125;&quot;, channel);        &#125;    &#125;&#125;\n\n\n\n多路复用单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用\n\n多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用\n如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证\n有可连接事件时才去连接\n有可读事件才去读取\n有可写事件才去写入\n限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件\n\n\n\n\n\n4.2 Selectorgraph TDsubgraph selector 版thread --&gt; selectorselector --&gt; c1(channel)selector --&gt; c2(channel)selector --&gt; c3(channel)end\n\n\n\n好处\n\n一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功\n让这个线程能够被充分利用\n节约了线程的数量\n减少了线程上下文切换\n\n创建Selector selector = Selector.open();\n\n\n\n绑定 Channel 事件也称之为注册事件，绑定的事件 selector 才会关心 \nchannel.configureBlocking(false);SelectionKey key = channel.register(selector, 绑定事件);\n\n\nchannel 必须工作在非阻塞模式\nFileChannel 没有非阻塞模式，因此不能配合 selector 一起使用\n绑定的事件类型可以有\nconnect - 客户端连接成功时触发\naccept - 服务器端成功接受连接时触发\nread - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况\nwrite - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况\n\n\n\n监听 Channel 事件可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件\n方法1，阻塞直到绑定事件发生\nint count = selector.select();\n\n\n\n方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）\nint count = selector.select(long timeout);\n\n\n\n方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件\nint count = selector.selectNow();\n\n\n\n💡 select 何时不阻塞\n\n事件发生时\n客户端发起连接请求，会触发 accept 事件\n客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件\nchannel 可写，会触发 write 事件\n在 linux 下 nio bug 发生时\n\n\n调用 selector.wakeup()\n调用 selector.close()\nselector 所在线程 interrupt\n\n\n4.3 处理 accept 事件客户端代码为\npublic class Client &#123;    public static void main(String[] args) &#123;        try (Socket socket = new Socket(&quot;localhost&quot;, 8080)) &#123;            System.out.println(socket);            socket.getOutputStream().write(&quot;world&quot;.getBytes());            System.in.read();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n\n服务器端代码为\n@Slf4jpublic class ChannelDemo6 &#123;    public static void main(String[] args) &#123;        try (ServerSocketChannel channel = ServerSocketChannel.open()) &#123;            channel.bind(new InetSocketAddress(8080));            System.out.println(channel);            Selector selector = Selector.open();            channel.configureBlocking(false);            channel.register(selector, SelectionKey.OP_ACCEPT);            while (true) &#123;                int count = selector.select();//                int count = selector.selectNow();                log.debug(&quot;select count: &#123;&#125;&quot;, count);//                if(count &lt;= 0) &#123;//                    continue;//                &#125;                // 获取所有事件                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();                // 遍历所有事件，逐一处理                Iterator&lt;SelectionKey&gt; iter = keys.iterator();                while (iter.hasNext()) &#123;                    SelectionKey key = iter.next();                    // 判断事件类型                    if (key.isAcceptable()) &#123;                        ServerSocketChannel c = (ServerSocketChannel) key.channel();                        // 必须处理                        SocketChannel sc = c.accept();                        log.debug(&quot;&#123;&#125;&quot;, sc);                    &#125;                    // 处理完毕，必须将事件移除                    iter.remove();                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n\n💡 事件发生后能否不处理\n事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发\n\n4.4 处理 read 事件@Slf4jpublic class ChannelDemo6 &#123;    public static void main(String[] args) &#123;        try (ServerSocketChannel channel = ServerSocketChannel.open()) &#123;            channel.bind(new InetSocketAddress(8080));            System.out.println(channel);            Selector selector = Selector.open();            channel.configureBlocking(false);            channel.register(selector, SelectionKey.OP_ACCEPT);            while (true) &#123;                int count = selector.select();//                int count = selector.selectNow();                log.debug(&quot;select count: &#123;&#125;&quot;, count);//                if(count &lt;= 0) &#123;//                    continue;//                &#125;                // 获取所有事件                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();                // 遍历所有事件，逐一处理                Iterator&lt;SelectionKey&gt; iter = keys.iterator();                while (iter.hasNext()) &#123;                    SelectionKey key = iter.next();                    // 判断事件类型                    if (key.isAcceptable()) &#123;                        ServerSocketChannel c = (ServerSocketChannel) key.channel();                        // 必须处理                        SocketChannel sc = c.accept();                        sc.configureBlocking(false);                        sc.register(selector, SelectionKey.OP_READ);                        log.debug(&quot;连接已建立: &#123;&#125;&quot;, sc);                    &#125; else if (key.isReadable()) &#123;                        SocketChannel sc = (SocketChannel) key.channel();                        ByteBuffer buffer = ByteBuffer.allocate(128);                        int read = sc.read(buffer);                        if(read == -1) &#123;                            key.cancel();                            sc.close();                        &#125; else &#123;                            buffer.flip();                            debug(buffer);                        &#125;                    &#125;                    // 处理完毕，必须将事件移除                    iter.remove();                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n开启两个客户端，修改一下发送文字，输出\nsun.nio.ch.ServerSocketChannelImpl[&#x2F;0:0:0:0:0:0:0:0:8080]21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 121:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:60367]21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f                                  |hello           |+--------+-------------------------------------------------+----------------+21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 121:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local&#x3D;&#x2F;127.0.0.1:8080 remote&#x3D;&#x2F;127.0.0.1:60378]21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 77 6f 72 6c 64                                  |world           |+--------+-------------------------------------------------+----------------+\n\n\n\n💡 为何要 iter.remove()\n因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如\n\n第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey \n第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常\n\n\n💡 cancel 的作用\ncancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件\n\n⚠️  不处理边界的问题以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的\npublic class Server &#123;    public static void main(String[] args) throws IOException &#123;        ServerSocket ss=new ServerSocket(9000);        while (true) &#123;            Socket s = ss.accept();            InputStream in = s.getInputStream();            // 这里这么写，有没有问题            byte[] arr = new byte[4];            while(true) &#123;                int read = in.read(arr);                // 这里这么写，有没有问题                if(read == -1) &#123;                    break;                &#125;                System.out.println(new String(arr, 0, read));            &#125;        &#125;    &#125;&#125;\n\n客户端\npublic class Client &#123;    public static void main(String[] args) throws IOException &#123;        Socket max = new Socket(&quot;localhost&quot;, 9000);        OutputStream out = max.getOutputStream();        out.write(&quot;hello&quot;.getBytes());        out.write(&quot;world&quot;.getBytes());        out.write(&quot;你好&quot;.getBytes());        max.close();    &#125;&#125;\n\n输出\nhelloworld��好\n\n为什么？\n处理消息的边界\n\n一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽\n另一种思路是按分隔符拆分，缺点是效率低\nTLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量\nHttp 1.1 是 TLV 格式\nHttp 2.0 是 LTV 格式\n\n\n\nsequenceDiagram participant c1 as 客户端1participant s as 服务器participant b1 as ByteBuffer1participant b2 as ByteBuffer2c1 -&gt;&gt; s: 发送 01234567890abcdef3333\\rs -&gt;&gt; b1: 第一次 read 存入 01234567890abcdefs -&gt;&gt; b2: 扩容b1 -&gt;&gt; b2: 拷贝 01234567890abcdefs -&gt;&gt; b2: 第二次 read 存入 3333\\rb2 -&gt;&gt; b2: 01234567890abcdef3333\\r\n\n服务器端\nprivate static void split(ByteBuffer source) &#123;    source.flip();    for (int i = 0; i &lt; source.limit(); i++) &#123;        // 找到一条完整消息        if (source.get(i) == &#x27;\\n&#x27;) &#123;            int length = i + 1 - source.position();            // 把这条完整消息存入新的 ByteBuffer            ByteBuffer target = ByteBuffer.allocate(length);            // 从 source 读，向 target 写            for (int j = 0; j &lt; length; j++) &#123;                target.put(source.get());            &#125;            debugAll(target);        &#125;    &#125;    source.compact(); // 0123456789abcdef  position 16 limit 16&#125;public static void main(String[] args) throws IOException &#123;    // 1. 创建 selector, 管理多个 channel    Selector selector = Selector.open();    ServerSocketChannel ssc = ServerSocketChannel.open();    ssc.configureBlocking(false);    // 2. 建立 selector 和 channel 的联系（注册）    // SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件    SelectionKey sscKey = ssc.register(selector, 0, null);    // key 只关注 accept 事件    sscKey.interestOps(SelectionKey.OP_ACCEPT);    log.debug(&quot;sscKey:&#123;&#125;&quot;, sscKey);    ssc.bind(new InetSocketAddress(8080));    while (true) &#123;        // 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行        // select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理        selector.select();        // 4. 处理事件, selectedKeys 内部包含了所有发生的事件        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); // accept, read        while (iter.hasNext()) &#123;            SelectionKey key = iter.next();            // 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题            iter.remove();            log.debug(&quot;key: &#123;&#125;&quot;, key);            // 5. 区分事件类型            if (key.isAcceptable()) &#123; // 如果是 accept                ServerSocketChannel channel = (ServerSocketChannel) key.channel();                SocketChannel sc = channel.accept();                sc.configureBlocking(false);                ByteBuffer buffer = ByteBuffer.allocate(16); // attachment                // 将一个 byteBuffer 作为附件关联到 selectionKey 上                SelectionKey scKey = sc.register(selector, 0, buffer);                scKey.interestOps(SelectionKey.OP_READ);                log.debug(&quot;&#123;&#125;&quot;, sc);                log.debug(&quot;scKey:&#123;&#125;&quot;, scKey);            &#125; else if (key.isReadable()) &#123; // 如果是 read                try &#123;                    SocketChannel channel = (SocketChannel) key.channel(); // 拿到触发事件的channel                    // 获取 selectionKey 上关联的附件                    ByteBuffer buffer = (ByteBuffer) key.attachment();                    int read = channel.read(buffer); // 如果是正常断开，read 的方法的返回值是 -1                    if(read == -1) &#123;                        key.cancel();                    &#125; else &#123;                        split(buffer);                        // 需要扩容                        if (buffer.position() == buffer.limit()) &#123;                            ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * 2);                            buffer.flip();                            newBuffer.put(buffer); // 0123456789abcdef3333\\n                            key.attach(newBuffer);                        &#125;                    &#125;                &#125; catch (IOException e) &#123;                    e.printStackTrace();                    key.cancel();  // 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）                &#125;            &#125;        &#125;    &#125;&#125;\n\n客户端\nSocketChannel sc = SocketChannel.open();sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));SocketAddress address = sc.getLocalAddress();// sc.write(Charset.defaultCharset().encode(&quot;hello\\nworld\\n&quot;));sc.write(Charset.defaultCharset().encode(&quot;0123\\n456789abcdef&quot;));sc.write(Charset.defaultCharset().encode(&quot;0123456789abcdef3333\\n&quot;));System.in.read();\n\n\n\n\n\nByteBuffer 大小分配\n每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer\nByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer\n一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 http://tutorials.jenkov.com/java-performance/resizable-array.html\n另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗\n\n\n\n4.5 处理 write 事件一次无法写完例子\n非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）\n用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略\n当消息处理器第一次写入消息时，才将 channel 注册到 selector 上\nselector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册\n如果不取消，会每次可写均会触发 write 事件\n\n\n\npublic class WriteServer &#123;    public static void main(String[] args) throws IOException &#123;        ServerSocketChannel ssc = ServerSocketChannel.open();        ssc.configureBlocking(false);        ssc.bind(new InetSocketAddress(8080));        Selector selector = Selector.open();        ssc.register(selector, SelectionKey.OP_ACCEPT);        while(true) &#123;            selector.select();            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();            while (iter.hasNext()) &#123;                SelectionKey key = iter.next();                iter.remove();                if (key.isAcceptable()) &#123;                    SocketChannel sc = ssc.accept();                    sc.configureBlocking(false);                    SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ);                    // 1. 向客户端发送内容                    StringBuilder sb = new StringBuilder();                    for (int i = 0; i &lt; 3000000; i++) &#123;                        sb.append(&quot;a&quot;);                    &#125;                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());                    int write = sc.write(buffer);                    // 3. write 表示实际写了多少字节                    System.out.println(&quot;实际写入字节:&quot; + write);                    // 4. 如果有剩余未读字节，才需要关注写事件                    if (buffer.hasRemaining()) &#123;                        // read 1  write 4                        // 在原有关注事件的基础上，多关注 写事件                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);                        // 把 buffer 作为附件加入 sckey                        sckey.attach(buffer);                    &#125;                &#125; else if (key.isWritable()) &#123;                    ByteBuffer buffer = (ByteBuffer) key.attachment();                    SocketChannel sc = (SocketChannel) key.channel();                    int write = sc.write(buffer);                    System.out.println(&quot;实际写入字节:&quot; + write);                    if (!buffer.hasRemaining()) &#123; // 写完了                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);                        key.attach(null);                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\n客户端\npublic class WriteClient &#123;    public static void main(String[] args) throws IOException &#123;        Selector selector = Selector.open();        SocketChannel sc = SocketChannel.open();        sc.configureBlocking(false);        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));        int count = 0;        while (true) &#123;            selector.select();            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();            while (iter.hasNext()) &#123;                SelectionKey key = iter.next();                iter.remove();                if (key.isConnectable()) &#123;                    System.out.println(sc.finishConnect());                &#125; else if (key.isReadable()) &#123;                    ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);                    count += sc.read(buffer);                    buffer.clear();                    System.out.println(count);                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n💡 write 为何要取消只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注\n4.6 更进一步💡 利用多线程优化\n现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费\n\n前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？\n分两组选择器\n\n单线程配一个选择器，专门处理 accept 事件\n创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件\n\npublic class ChannelDemo7 &#123;    public static void main(String[] args) throws IOException &#123;        new BossEventLoop().register();    &#125;    @Slf4j    static class BossEventLoop implements Runnable &#123;        private Selector boss;        private WorkerEventLoop[] workers;        private volatile boolean start = false;        AtomicInteger index = new AtomicInteger();        public void register() throws IOException &#123;            if (!start) &#123;                ServerSocketChannel ssc = ServerSocketChannel.open();                ssc.bind(new InetSocketAddress(8080));                ssc.configureBlocking(false);                boss = Selector.open();                SelectionKey ssckey = ssc.register(boss, 0, null);                ssckey.interestOps(SelectionKey.OP_ACCEPT);                workers = initEventLoops();                new Thread(this, &quot;boss&quot;).start();                log.debug(&quot;boss start...&quot;);                start = true;            &#125;        &#125;        public WorkerEventLoop[] initEventLoops() &#123;//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];            WorkerEventLoop[] workerEventLoops = new WorkerEventLoop[2];            for (int i = 0; i &lt; workerEventLoops.length; i++) &#123;                workerEventLoops[i] = new WorkerEventLoop(i);            &#125;            return workerEventLoops;        &#125;        @Override        public void run() &#123;            while (true) &#123;                try &#123;                    boss.select();                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();                    while (iter.hasNext()) &#123;                        SelectionKey key = iter.next();                        iter.remove();                        if (key.isAcceptable()) &#123;                            ServerSocketChannel c = (ServerSocketChannel) key.channel();                            SocketChannel sc = c.accept();                            sc.configureBlocking(false);                            log.debug(&quot;&#123;&#125; connected&quot;, sc.getRemoteAddress());                            workers[index.getAndIncrement() % workers.length].register(sc);                        &#125;                    &#125;                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    @Slf4j    static class WorkerEventLoop implements Runnable &#123;        private Selector worker;        private volatile boolean start = false;        private int index;        private final ConcurrentLinkedQueue&lt;Runnable&gt; tasks = new ConcurrentLinkedQueue&lt;&gt;();        public WorkerEventLoop(int index) &#123;            this.index = index;        &#125;        public void register(SocketChannel sc) throws IOException &#123;            if (!start) &#123;                worker = Selector.open();                new Thread(this, &quot;worker-&quot; + index).start();                start = true;            &#125;            tasks.add(() -&gt; &#123;                try &#123;                    SelectionKey sckey = sc.register(worker, 0, null);                    sckey.interestOps(SelectionKey.OP_READ);                    worker.selectNow();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;);            worker.wakeup();        &#125;        @Override        public void run() &#123;            while (true) &#123;                try &#123;                    worker.select();                    Runnable task = tasks.poll();                    if (task != null) &#123;                        task.run();                    &#125;                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();                    while (iter.hasNext()) &#123;                        SelectionKey key = iter.next();                        if (key.isReadable()) &#123;                            SocketChannel sc = (SocketChannel) key.channel();                            ByteBuffer buffer = ByteBuffer.allocate(128);                            try &#123;                                int read = sc.read(buffer);                                if (read == -1) &#123;                                    key.cancel();                                    sc.close();                                &#125; else &#123;                                    buffer.flip();                                    log.debug(&quot;&#123;&#125; message:&quot;, sc.getRemoteAddress());                                    debugAll(buffer);                                &#125;                            &#125; catch (IOException e) &#123;                                e.printStackTrace();                                key.cancel();                                sc.close();                            &#125;                        &#125;                        iter.remove();                    &#125;                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n💡 如何拿到 cpu 个数\n\nRuntime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数\n这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启\n\n\n4.7 UDP\nUDP 是无连接的，client 发送数据不会管 server 是否开启\nserver 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃\n\n首先启动服务器端\npublic class UdpServer &#123;    public static void main(String[] args) &#123;        try (DatagramChannel channel = DatagramChannel.open()) &#123;            channel.socket().bind(new InetSocketAddress(9999));            System.out.println(&quot;waiting...&quot;);            ByteBuffer buffer = ByteBuffer.allocate(32);            channel.receive(buffer);            buffer.flip();            debug(buffer);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n输出\nwaiting...\n\n\n\n运行客户端\npublic class UdpClient &#123;    public static void main(String[] args) &#123;        try (DatagramChannel channel = DatagramChannel.open()) &#123;            ByteBuffer buffer = StandardCharsets.UTF_8.encode(&quot;hello&quot;);            InetSocketAddress address = new InetSocketAddress(&quot;localhost&quot;, 9999);            channel.send(buffer, address);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n接下来服务器端输出\n         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 68 65 6c 6c 6f                                  |hello           |+--------+-------------------------------------------------+----------------+\n\n\n\n\n\n5. NIO vs BIO5.1 stream vs channel\nstream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）\nstream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用\n二者均为全双工，即读写可以同时进行\n\n5.2 IO 模型同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞\n\n同步：线程自己去获取结果（一个线程）\n异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）\n\n当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：\n\n等待数据阶段\n复制数据阶段\n\n\n\n阻塞 IO\n\n\n\n非阻塞  IO\n\n \n\n多路复用\n\n \n\n信号驱动\n\n异步 IO\n\n\n阻塞 IO vs 多路复用\n\n\n\n\n🔖 参考UNIX 网络编程 - 卷 I\n5.3 零拷贝传统 IO 问题传统的 IO 将一个文件通过 socket 写出\nFile f = new File(&quot;helloword/data.txt&quot;);RandomAccessFile file = new RandomAccessFile(file, &quot;r&quot;);byte[] buf = new byte[(int)f.length()];file.read(buf);Socket socket = ...;socket.getOutputStream().write(buf);\n\n内部工作流程是这样的：\n\n\njava 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的用户态切换至内核态，去调用操作系统（Kernel）的读能力，将数据读入内核缓冲区。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu\n\nDMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO\n\n\n从内核态切换回用户态，将数据从内核缓冲区读入用户缓冲区（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA\n\n调用 write 方法，这时将数据从用户缓冲区（byte[] buf）写入 socket 缓冲区，cpu 会参与拷贝\n\n接下来要向网卡写数据，这项能力 java 又不具备，因此又得从用户态切换至内核态，调用操作系统的写能力，使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 cpu\n\n\n可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的\n\n用户态与内核态的切换发生了 3 次，这个操作比较重量级\n数据拷贝了共 4 次\n\nNIO 优化通过 DirectByteBuf \n\nByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存\nByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存\n\n\n大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用\n\n这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写\njava 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步\nDirectByteBuf 对象被垃圾回收，将虚引用加入引用队列\n通过专门线程访问引用队列，根据虚引用释放堆外内存\n\n\n减少了一次数据拷贝，用户态与内核态的切换次数没有减少\n\n进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据\n\n\njava 调用 transferTo 方法后，要从 java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 cpu\n数据从内核缓冲区传输到 socket 缓冲区，cpu 会参与拷贝\n最后使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 cpu\n\n可以看到\n\n只发生了一次用户态与内核态的切换\n数据拷贝了 3 次\n\n进一步优化（linux 2.4）\n\n\njava 调用 transferTo 方法后，要从 java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 cpu\n只会将一些 offset 和 length 信息拷入 socket 缓冲区，几乎无消耗\n使用 DMA 将 内核缓冲区的数据写入网卡，不会使用 cpu\n\n整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有\n\n更少的用户态与内核态的切换\n不利用 cpu 计算，减少 cpu 缓存伪共享\n零拷贝适合小文件传输\n\n5.3 AIOAIO 用来解决数据复制阶段的阻塞问题\n\n同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置\n异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果\n\n\n异步模型需要底层操作系统（Kernel）提供支持\n\nWindows 系统通过 IOCP 实现了真正的异步 IO\nLinux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势\n\n\n文件 AIO先来看看 AsynchronousFileChannel\n@Slf4jpublic class AioDemo1 &#123;    public static void main(String[] args) throws IOException &#123;        try&#123;            AsynchronousFileChannel s =                 AsynchronousFileChannel.open(                \tPaths.get(&quot;1.txt&quot;), StandardOpenOption.READ);            ByteBuffer buffer = ByteBuffer.allocate(2);            log.debug(&quot;begin...&quot;);            s.read(buffer, 0, null, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;                @Override                public void completed(Integer result, ByteBuffer attachment) &#123;                    log.debug(&quot;read completed...&#123;&#125;&quot;, result);                    buffer.flip();                    debug(buffer);                &#125;                @Override                public void failed(Throwable exc, ByteBuffer attachment) &#123;                    log.debug(&quot;read failed...&quot;);                &#125;            &#125;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        log.debug(&quot;do other things...&quot;);        System.in.read();    &#125;&#125;\n\n输出\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2         +-------------------------------------------------+         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |+--------+-------------------------------------------------+----------------+|00000000| 61 0d                                           |a.              |+--------+-------------------------------------------------+----------------+\n\n可以看到\n\n响应文件读取成功的是另一个线程 Thread-5\n主线程并没有 IO 操作阻塞\n\n💡 守护线程默认文件 AIO 使用的线程都是守护线程，所以最后要执行 System.in.read() 以避免守护线程意外结束\n网络 AIOpublic class AioServer &#123;    public static void main(String[] args) throws IOException &#123;        AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open();        ssc.bind(new InetSocketAddress(8080));        ssc.accept(null, new AcceptHandler(ssc));        System.in.read();    &#125;    private static void closeChannel(AsynchronousSocketChannel sc) &#123;        try &#123;            System.out.printf(&quot;[%s] %s close\\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());            sc.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    private static class ReadHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;        private final AsynchronousSocketChannel sc;        public ReadHandler(AsynchronousSocketChannel sc) &#123;            this.sc = sc;        &#125;        @Override        public void completed(Integer result, ByteBuffer attachment) &#123;            try &#123;                if (result == -1) &#123;                    closeChannel(sc);                    return;                &#125;                System.out.printf(&quot;[%s] %s read\\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());                attachment.flip();                System.out.println(Charset.defaultCharset().decode(attachment));                attachment.clear();                // 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件                sc.read(attachment, attachment, this);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        @Override        public void failed(Throwable exc, ByteBuffer attachment) &#123;            closeChannel(sc);            exc.printStackTrace();        &#125;    &#125;    private static class WriteHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;        private final AsynchronousSocketChannel sc;        private WriteHandler(AsynchronousSocketChannel sc) &#123;            this.sc = sc;        &#125;        @Override        public void completed(Integer result, ByteBuffer attachment) &#123;            // 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容            if (attachment.hasRemaining()) &#123;                sc.write(attachment);            &#125;        &#125;        @Override        public void failed(Throwable exc, ByteBuffer attachment) &#123;            exc.printStackTrace();            closeChannel(sc);        &#125;    &#125;    private static class AcceptHandler implements CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; &#123;        private final AsynchronousServerSocketChannel ssc;        public AcceptHandler(AsynchronousServerSocketChannel ssc) &#123;            this.ssc = ssc;        &#125;        @Override        public void completed(AsynchronousSocketChannel sc, Object attachment) &#123;            try &#123;                System.out.printf(&quot;[%s] %s connected\\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            ByteBuffer buffer = ByteBuffer.allocate(16);            // 读事件由 ReadHandler 处理            sc.read(buffer, buffer, new ReadHandler(sc));            // 写事件由 WriteHandler 处理            sc.write(Charset.defaultCharset().encode(&quot;server hello!&quot;), ByteBuffer.allocate(16), new WriteHandler(sc));            // 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件            ssc.accept(null, this);        &#125;        @Override        public void failed(Throwable exc, Object attachment) &#123;            exc.printStackTrace();        &#125;    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["java"],"tags":["netty"]}]